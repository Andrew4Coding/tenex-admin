
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/**
 * WARNING: This is an internal file that is subject to change!
 * 
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 * 
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 * 
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective 
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/library"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Validator
 */
export const validator = runtime.Public.validator

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
 * Metrics
 */
export type Metrics = runtime.Metrics
export type Metric<T> = runtime.Metric<T>
export type MetricHistogram = runtime.MetricHistogram
export type MetricHistogramBucket = runtime.MetricHistogramBucket

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 6.11.1
 * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
 */
export const prismaVersion: PrismaVersion = {
  client: "6.11.1",
  engine: "f40f79ec31188888a2e33acda0ecc8fd10a853a9"
}

/**
 * Utility Types
 */

export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue

export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.DbNull),
  JsonNull: runtime.objectEnumValues.classes.JsonNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.JsonNull),
  AnyNull: runtime.objectEnumValues.classes.AnyNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.AnyNull),
}

/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull

type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  AdWatchHistory: 'AdWatchHistory',
  AdWatchSession: 'AdWatchSession',
  Advertisement: 'Advertisement',
  Announcement: 'Announcement',
  Article: 'Article',
  CVClinicClaim: 'CVClinicClaim',
  CVClinicVouchers: 'CVClinicVouchers',
  DashboardNotification: 'DashboardNotification',
  DashboardNotificationUserRead: 'DashboardNotificationUserRead',
  Event: 'Event',
  EventDate: 'EventDate',
  EventRegistration: 'EventRegistration',
  Exhibitor: 'Exhibitor',
  ExploreITFunfact: 'ExploreITFunfact',
  Feedback: 'Feedback',
  FeedbackOption: 'FeedbackOption',
  FeedbackQuestion: 'FeedbackQuestion',
  FeedbackSubmission: 'FeedbackSubmission',
  Game: 'Game',
  GameDeveloper: 'GameDeveloper',
  GameRule: 'GameRule',
  GrandLaunchingRegistration: 'GrandLaunchingRegistration',
  LeaderBoardHistory: 'LeaderBoardHistory',
  Member: 'Member',
  MiniQuiz: 'MiniQuiz',
  MiniQuizAttempt: 'MiniQuizAttempt',
  MiniQuizQuestion: 'MiniQuizQuestion',
  Nominee: 'Nominee',
  NomineeVote: 'NomineeVote',
  PlaygroundExpenseHistory: 'PlaygroundExpenseHistory',
  PlaygroundRewardHistory: 'PlaygroundRewardHistory',
  PlaygroundToken: 'PlaygroundToken',
  Program: 'Program',
  ProgramRegistration: 'ProgramRegistration',
  ProgramTask: 'ProgramTask',
  ProgramTaskExtraDescription: 'ProgramTaskExtraDescription',
  ProgramTaskSubmission: 'ProgramTaskSubmission',
  Project: 'Project',
  ReferalCodeUsage: 'ReferalCodeUsage',
  SingleParticipant: 'SingleParticipant',
  Team: 'Team',
  UserData: 'UserData',
  UserPlayGameHistory: 'UserPlayGameHistory',
  UserPlayground: 'UserPlayground',
  UserPlaygroundDetention: 'UserPlaygroundDetention',
  account: 'account',
  rateLimit: 'rateLimit',
  session: 'session',
  user: 'user',
  verification: 'verification'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<ClientOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "adWatchHistory" | "adWatchSession" | "advertisement" | "announcement" | "article" | "cVClinicClaim" | "cVClinicVouchers" | "dashboardNotification" | "dashboardNotificationUserRead" | "event" | "eventDate" | "eventRegistration" | "exhibitor" | "exploreITFunfact" | "feedback" | "feedbackOption" | "feedbackQuestion" | "feedbackSubmission" | "game" | "gameDeveloper" | "gameRule" | "grandLaunchingRegistration" | "leaderBoardHistory" | "member" | "miniQuiz" | "miniQuizAttempt" | "miniQuizQuestion" | "nominee" | "nomineeVote" | "playgroundExpenseHistory" | "playgroundRewardHistory" | "playgroundToken" | "program" | "programRegistration" | "programTask" | "programTaskExtraDescription" | "programTaskSubmission" | "project" | "referalCodeUsage" | "singleParticipant" | "team" | "userData" | "userPlayGameHistory" | "userPlayground" | "userPlaygroundDetention" | "account" | "rateLimit" | "session" | "user" | "verification"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    AdWatchHistory: {
      payload: Prisma.$AdWatchHistoryPayload<ExtArgs>
      fields: Prisma.AdWatchHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AdWatchHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AdWatchHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload>
        }
        findFirst: {
          args: Prisma.AdWatchHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AdWatchHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload>
        }
        findMany: {
          args: Prisma.AdWatchHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload>[]
        }
        create: {
          args: Prisma.AdWatchHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload>
        }
        createMany: {
          args: Prisma.AdWatchHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AdWatchHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload>[]
        }
        delete: {
          args: Prisma.AdWatchHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload>
        }
        update: {
          args: Prisma.AdWatchHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload>
        }
        deleteMany: {
          args: Prisma.AdWatchHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AdWatchHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AdWatchHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload>[]
        }
        upsert: {
          args: Prisma.AdWatchHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchHistoryPayload>
        }
        aggregate: {
          args: Prisma.AdWatchHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAdWatchHistory>
        }
        groupBy: {
          args: Prisma.AdWatchHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdWatchHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.AdWatchHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdWatchHistoryCountAggregateOutputType> | number
        }
      }
    }
    AdWatchSession: {
      payload: Prisma.$AdWatchSessionPayload<ExtArgs>
      fields: Prisma.AdWatchSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AdWatchSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AdWatchSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload>
        }
        findFirst: {
          args: Prisma.AdWatchSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AdWatchSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload>
        }
        findMany: {
          args: Prisma.AdWatchSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload>[]
        }
        create: {
          args: Prisma.AdWatchSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload>
        }
        createMany: {
          args: Prisma.AdWatchSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AdWatchSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload>[]
        }
        delete: {
          args: Prisma.AdWatchSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload>
        }
        update: {
          args: Prisma.AdWatchSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload>
        }
        deleteMany: {
          args: Prisma.AdWatchSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AdWatchSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AdWatchSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload>[]
        }
        upsert: {
          args: Prisma.AdWatchSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdWatchSessionPayload>
        }
        aggregate: {
          args: Prisma.AdWatchSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAdWatchSession>
        }
        groupBy: {
          args: Prisma.AdWatchSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdWatchSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.AdWatchSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdWatchSessionCountAggregateOutputType> | number
        }
      }
    }
    Advertisement: {
      payload: Prisma.$AdvertisementPayload<ExtArgs>
      fields: Prisma.AdvertisementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AdvertisementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AdvertisementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload>
        }
        findFirst: {
          args: Prisma.AdvertisementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AdvertisementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload>
        }
        findMany: {
          args: Prisma.AdvertisementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload>[]
        }
        create: {
          args: Prisma.AdvertisementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload>
        }
        createMany: {
          args: Prisma.AdvertisementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AdvertisementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload>[]
        }
        delete: {
          args: Prisma.AdvertisementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload>
        }
        update: {
          args: Prisma.AdvertisementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload>
        }
        deleteMany: {
          args: Prisma.AdvertisementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AdvertisementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AdvertisementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload>[]
        }
        upsert: {
          args: Prisma.AdvertisementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdvertisementPayload>
        }
        aggregate: {
          args: Prisma.AdvertisementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAdvertisement>
        }
        groupBy: {
          args: Prisma.AdvertisementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdvertisementGroupByOutputType>[]
        }
        count: {
          args: Prisma.AdvertisementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdvertisementCountAggregateOutputType> | number
        }
      }
    }
    Announcement: {
      payload: Prisma.$AnnouncementPayload<ExtArgs>
      fields: Prisma.AnnouncementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        findFirst: {
          args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        findMany: {
          args: Prisma.AnnouncementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        create: {
          args: Prisma.AnnouncementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        createMany: {
          args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        delete: {
          args: Prisma.AnnouncementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        update: {
          args: Prisma.AnnouncementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        deleteMany: {
          args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        upsert: {
          args: Prisma.AnnouncementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        aggregate: {
          args: Prisma.AnnouncementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnnouncement>
        }
        groupBy: {
          args: Prisma.AnnouncementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementGroupByOutputType>[]
        }
        count: {
          args: Prisma.AnnouncementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementCountAggregateOutputType> | number
        }
      }
    }
    Article: {
      payload: Prisma.$ArticlePayload<ExtArgs>
      fields: Prisma.ArticleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArticleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload>
        }
        findFirst: {
          args: Prisma.ArticleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload>
        }
        findMany: {
          args: Prisma.ArticleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload>[]
        }
        create: {
          args: Prisma.ArticleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload>
        }
        createMany: {
          args: Prisma.ArticleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArticleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload>[]
        }
        delete: {
          args: Prisma.ArticleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload>
        }
        update: {
          args: Prisma.ArticleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload>
        }
        deleteMany: {
          args: Prisma.ArticleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArticleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArticleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload>[]
        }
        upsert: {
          args: Prisma.ArticleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArticlePayload>
        }
        aggregate: {
          args: Prisma.ArticleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArticle>
        }
        groupBy: {
          args: Prisma.ArticleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArticleGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArticleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArticleCountAggregateOutputType> | number
        }
      }
    }
    CVClinicClaim: {
      payload: Prisma.$CVClinicClaimPayload<ExtArgs>
      fields: Prisma.CVClinicClaimFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CVClinicClaimFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CVClinicClaimFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload>
        }
        findFirst: {
          args: Prisma.CVClinicClaimFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CVClinicClaimFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload>
        }
        findMany: {
          args: Prisma.CVClinicClaimFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload>[]
        }
        create: {
          args: Prisma.CVClinicClaimCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload>
        }
        createMany: {
          args: Prisma.CVClinicClaimCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CVClinicClaimCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload>[]
        }
        delete: {
          args: Prisma.CVClinicClaimDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload>
        }
        update: {
          args: Prisma.CVClinicClaimUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload>
        }
        deleteMany: {
          args: Prisma.CVClinicClaimDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CVClinicClaimUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CVClinicClaimUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload>[]
        }
        upsert: {
          args: Prisma.CVClinicClaimUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicClaimPayload>
        }
        aggregate: {
          args: Prisma.CVClinicClaimAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCVClinicClaim>
        }
        groupBy: {
          args: Prisma.CVClinicClaimGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CVClinicClaimGroupByOutputType>[]
        }
        count: {
          args: Prisma.CVClinicClaimCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CVClinicClaimCountAggregateOutputType> | number
        }
      }
    }
    CVClinicVouchers: {
      payload: Prisma.$CVClinicVouchersPayload<ExtArgs>
      fields: Prisma.CVClinicVouchersFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CVClinicVouchersFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CVClinicVouchersFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload>
        }
        findFirst: {
          args: Prisma.CVClinicVouchersFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CVClinicVouchersFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload>
        }
        findMany: {
          args: Prisma.CVClinicVouchersFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload>[]
        }
        create: {
          args: Prisma.CVClinicVouchersCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload>
        }
        createMany: {
          args: Prisma.CVClinicVouchersCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CVClinicVouchersCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload>[]
        }
        delete: {
          args: Prisma.CVClinicVouchersDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload>
        }
        update: {
          args: Prisma.CVClinicVouchersUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload>
        }
        deleteMany: {
          args: Prisma.CVClinicVouchersDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CVClinicVouchersUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CVClinicVouchersUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload>[]
        }
        upsert: {
          args: Prisma.CVClinicVouchersUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CVClinicVouchersPayload>
        }
        aggregate: {
          args: Prisma.CVClinicVouchersAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCVClinicVouchers>
        }
        groupBy: {
          args: Prisma.CVClinicVouchersGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CVClinicVouchersGroupByOutputType>[]
        }
        count: {
          args: Prisma.CVClinicVouchersCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CVClinicVouchersCountAggregateOutputType> | number
        }
      }
    }
    DashboardNotification: {
      payload: Prisma.$DashboardNotificationPayload<ExtArgs>
      fields: Prisma.DashboardNotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DashboardNotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DashboardNotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload>
        }
        findFirst: {
          args: Prisma.DashboardNotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DashboardNotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload>
        }
        findMany: {
          args: Prisma.DashboardNotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload>[]
        }
        create: {
          args: Prisma.DashboardNotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload>
        }
        createMany: {
          args: Prisma.DashboardNotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DashboardNotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload>[]
        }
        delete: {
          args: Prisma.DashboardNotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload>
        }
        update: {
          args: Prisma.DashboardNotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload>
        }
        deleteMany: {
          args: Prisma.DashboardNotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DashboardNotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DashboardNotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload>[]
        }
        upsert: {
          args: Prisma.DashboardNotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationPayload>
        }
        aggregate: {
          args: Prisma.DashboardNotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDashboardNotification>
        }
        groupBy: {
          args: Prisma.DashboardNotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DashboardNotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.DashboardNotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DashboardNotificationCountAggregateOutputType> | number
        }
      }
    }
    DashboardNotificationUserRead: {
      payload: Prisma.$DashboardNotificationUserReadPayload<ExtArgs>
      fields: Prisma.DashboardNotificationUserReadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DashboardNotificationUserReadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DashboardNotificationUserReadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload>
        }
        findFirst: {
          args: Prisma.DashboardNotificationUserReadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DashboardNotificationUserReadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload>
        }
        findMany: {
          args: Prisma.DashboardNotificationUserReadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload>[]
        }
        create: {
          args: Prisma.DashboardNotificationUserReadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload>
        }
        createMany: {
          args: Prisma.DashboardNotificationUserReadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DashboardNotificationUserReadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload>[]
        }
        delete: {
          args: Prisma.DashboardNotificationUserReadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload>
        }
        update: {
          args: Prisma.DashboardNotificationUserReadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload>
        }
        deleteMany: {
          args: Prisma.DashboardNotificationUserReadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DashboardNotificationUserReadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DashboardNotificationUserReadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload>[]
        }
        upsert: {
          args: Prisma.DashboardNotificationUserReadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardNotificationUserReadPayload>
        }
        aggregate: {
          args: Prisma.DashboardNotificationUserReadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDashboardNotificationUserRead>
        }
        groupBy: {
          args: Prisma.DashboardNotificationUserReadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DashboardNotificationUserReadGroupByOutputType>[]
        }
        count: {
          args: Prisma.DashboardNotificationUserReadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DashboardNotificationUserReadCountAggregateOutputType> | number
        }
      }
    }
    Event: {
      payload: Prisma.$EventPayload<ExtArgs>
      fields: Prisma.EventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        findFirst: {
          args: Prisma.EventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        findMany: {
          args: Prisma.EventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        create: {
          args: Prisma.EventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        createMany: {
          args: Prisma.EventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        delete: {
          args: Prisma.EventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        update: {
          args: Prisma.EventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        deleteMany: {
          args: Prisma.EventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        upsert: {
          args: Prisma.EventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        aggregate: {
          args: Prisma.EventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEvent>
        }
        groupBy: {
          args: Prisma.EventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventCountAggregateOutputType> | number
        }
      }
    }
    EventDate: {
      payload: Prisma.$EventDatePayload<ExtArgs>
      fields: Prisma.EventDateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventDateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventDateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload>
        }
        findFirst: {
          args: Prisma.EventDateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventDateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload>
        }
        findMany: {
          args: Prisma.EventDateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload>[]
        }
        create: {
          args: Prisma.EventDateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload>
        }
        createMany: {
          args: Prisma.EventDateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventDateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload>[]
        }
        delete: {
          args: Prisma.EventDateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload>
        }
        update: {
          args: Prisma.EventDateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload>
        }
        deleteMany: {
          args: Prisma.EventDateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventDateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventDateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload>[]
        }
        upsert: {
          args: Prisma.EventDateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventDatePayload>
        }
        aggregate: {
          args: Prisma.EventDateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventDate>
        }
        groupBy: {
          args: Prisma.EventDateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventDateGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventDateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventDateCountAggregateOutputType> | number
        }
      }
    }
    EventRegistration: {
      payload: Prisma.$EventRegistrationPayload<ExtArgs>
      fields: Prisma.EventRegistrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventRegistrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventRegistrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        findFirst: {
          args: Prisma.EventRegistrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventRegistrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        findMany: {
          args: Prisma.EventRegistrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        create: {
          args: Prisma.EventRegistrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        createMany: {
          args: Prisma.EventRegistrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventRegistrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        delete: {
          args: Prisma.EventRegistrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        update: {
          args: Prisma.EventRegistrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        deleteMany: {
          args: Prisma.EventRegistrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventRegistrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventRegistrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        upsert: {
          args: Prisma.EventRegistrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        aggregate: {
          args: Prisma.EventRegistrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventRegistration>
        }
        groupBy: {
          args: Prisma.EventRegistrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventRegistrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationCountAggregateOutputType> | number
        }
      }
    }
    Exhibitor: {
      payload: Prisma.$ExhibitorPayload<ExtArgs>
      fields: Prisma.ExhibitorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExhibitorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExhibitorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload>
        }
        findFirst: {
          args: Prisma.ExhibitorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExhibitorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload>
        }
        findMany: {
          args: Prisma.ExhibitorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload>[]
        }
        create: {
          args: Prisma.ExhibitorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload>
        }
        createMany: {
          args: Prisma.ExhibitorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExhibitorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload>[]
        }
        delete: {
          args: Prisma.ExhibitorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload>
        }
        update: {
          args: Prisma.ExhibitorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload>
        }
        deleteMany: {
          args: Prisma.ExhibitorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExhibitorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExhibitorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload>[]
        }
        upsert: {
          args: Prisma.ExhibitorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExhibitorPayload>
        }
        aggregate: {
          args: Prisma.ExhibitorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExhibitor>
        }
        groupBy: {
          args: Prisma.ExhibitorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExhibitorGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExhibitorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExhibitorCountAggregateOutputType> | number
        }
      }
    }
    ExploreITFunfact: {
      payload: Prisma.$ExploreITFunfactPayload<ExtArgs>
      fields: Prisma.ExploreITFunfactFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExploreITFunfactFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExploreITFunfactFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload>
        }
        findFirst: {
          args: Prisma.ExploreITFunfactFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExploreITFunfactFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload>
        }
        findMany: {
          args: Prisma.ExploreITFunfactFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload>[]
        }
        create: {
          args: Prisma.ExploreITFunfactCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload>
        }
        createMany: {
          args: Prisma.ExploreITFunfactCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExploreITFunfactCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload>[]
        }
        delete: {
          args: Prisma.ExploreITFunfactDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload>
        }
        update: {
          args: Prisma.ExploreITFunfactUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload>
        }
        deleteMany: {
          args: Prisma.ExploreITFunfactDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExploreITFunfactUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExploreITFunfactUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload>[]
        }
        upsert: {
          args: Prisma.ExploreITFunfactUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExploreITFunfactPayload>
        }
        aggregate: {
          args: Prisma.ExploreITFunfactAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExploreITFunfact>
        }
        groupBy: {
          args: Prisma.ExploreITFunfactGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExploreITFunfactGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExploreITFunfactCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExploreITFunfactCountAggregateOutputType> | number
        }
      }
    }
    Feedback: {
      payload: Prisma.$FeedbackPayload<ExtArgs>
      fields: Prisma.FeedbackFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        findFirst: {
          args: Prisma.FeedbackFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        findMany: {
          args: Prisma.FeedbackFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
        }
        create: {
          args: Prisma.FeedbackCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        createMany: {
          args: Prisma.FeedbackCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
        }
        delete: {
          args: Prisma.FeedbackDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        update: {
          args: Prisma.FeedbackUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        deleteMany: {
          args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
        }
        upsert: {
          args: Prisma.FeedbackUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        aggregate: {
          args: Prisma.FeedbackAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFeedback>
        }
        groupBy: {
          args: Prisma.FeedbackGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeedbackGroupByOutputType>[]
        }
        count: {
          args: Prisma.FeedbackCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeedbackCountAggregateOutputType> | number
        }
      }
    }
    FeedbackOption: {
      payload: Prisma.$FeedbackOptionPayload<ExtArgs>
      fields: Prisma.FeedbackOptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FeedbackOptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FeedbackOptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload>
        }
        findFirst: {
          args: Prisma.FeedbackOptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FeedbackOptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload>
        }
        findMany: {
          args: Prisma.FeedbackOptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload>[]
        }
        create: {
          args: Prisma.FeedbackOptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload>
        }
        createMany: {
          args: Prisma.FeedbackOptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FeedbackOptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload>[]
        }
        delete: {
          args: Prisma.FeedbackOptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload>
        }
        update: {
          args: Prisma.FeedbackOptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload>
        }
        deleteMany: {
          args: Prisma.FeedbackOptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FeedbackOptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FeedbackOptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload>[]
        }
        upsert: {
          args: Prisma.FeedbackOptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackOptionPayload>
        }
        aggregate: {
          args: Prisma.FeedbackOptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFeedbackOption>
        }
        groupBy: {
          args: Prisma.FeedbackOptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeedbackOptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.FeedbackOptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeedbackOptionCountAggregateOutputType> | number
        }
      }
    }
    FeedbackQuestion: {
      payload: Prisma.$FeedbackQuestionPayload<ExtArgs>
      fields: Prisma.FeedbackQuestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FeedbackQuestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FeedbackQuestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>
        }
        findFirst: {
          args: Prisma.FeedbackQuestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FeedbackQuestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>
        }
        findMany: {
          args: Prisma.FeedbackQuestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>[]
        }
        create: {
          args: Prisma.FeedbackQuestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>
        }
        createMany: {
          args: Prisma.FeedbackQuestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FeedbackQuestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>[]
        }
        delete: {
          args: Prisma.FeedbackQuestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>
        }
        update: {
          args: Prisma.FeedbackQuestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>
        }
        deleteMany: {
          args: Prisma.FeedbackQuestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FeedbackQuestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FeedbackQuestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>[]
        }
        upsert: {
          args: Prisma.FeedbackQuestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>
        }
        aggregate: {
          args: Prisma.FeedbackQuestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFeedbackQuestion>
        }
        groupBy: {
          args: Prisma.FeedbackQuestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeedbackQuestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.FeedbackQuestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeedbackQuestionCountAggregateOutputType> | number
        }
      }
    }
    FeedbackSubmission: {
      payload: Prisma.$FeedbackSubmissionPayload<ExtArgs>
      fields: Prisma.FeedbackSubmissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FeedbackSubmissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FeedbackSubmissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload>
        }
        findFirst: {
          args: Prisma.FeedbackSubmissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FeedbackSubmissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload>
        }
        findMany: {
          args: Prisma.FeedbackSubmissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload>[]
        }
        create: {
          args: Prisma.FeedbackSubmissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload>
        }
        createMany: {
          args: Prisma.FeedbackSubmissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FeedbackSubmissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload>[]
        }
        delete: {
          args: Prisma.FeedbackSubmissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload>
        }
        update: {
          args: Prisma.FeedbackSubmissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload>
        }
        deleteMany: {
          args: Prisma.FeedbackSubmissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FeedbackSubmissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FeedbackSubmissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload>[]
        }
        upsert: {
          args: Prisma.FeedbackSubmissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSubmissionPayload>
        }
        aggregate: {
          args: Prisma.FeedbackSubmissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFeedbackSubmission>
        }
        groupBy: {
          args: Prisma.FeedbackSubmissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeedbackSubmissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.FeedbackSubmissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeedbackSubmissionCountAggregateOutputType> | number
        }
      }
    }
    Game: {
      payload: Prisma.$GamePayload<ExtArgs>
      fields: Prisma.GameFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GameFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload>
        }
        findFirst: {
          args: Prisma.GameFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload>
        }
        findMany: {
          args: Prisma.GameFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload>[]
        }
        create: {
          args: Prisma.GameCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload>
        }
        createMany: {
          args: Prisma.GameCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload>[]
        }
        delete: {
          args: Prisma.GameDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload>
        }
        update: {
          args: Prisma.GameUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload>
        }
        deleteMany: {
          args: Prisma.GameDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GameUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload>[]
        }
        upsert: {
          args: Prisma.GameUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GamePayload>
        }
        aggregate: {
          args: Prisma.GameAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGame>
        }
        groupBy: {
          args: Prisma.GameGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GameGroupByOutputType>[]
        }
        count: {
          args: Prisma.GameCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GameCountAggregateOutputType> | number
        }
      }
    }
    GameDeveloper: {
      payload: Prisma.$GameDeveloperPayload<ExtArgs>
      fields: Prisma.GameDeveloperFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GameDeveloperFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GameDeveloperFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload>
        }
        findFirst: {
          args: Prisma.GameDeveloperFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GameDeveloperFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload>
        }
        findMany: {
          args: Prisma.GameDeveloperFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload>[]
        }
        create: {
          args: Prisma.GameDeveloperCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload>
        }
        createMany: {
          args: Prisma.GameDeveloperCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GameDeveloperCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload>[]
        }
        delete: {
          args: Prisma.GameDeveloperDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload>
        }
        update: {
          args: Prisma.GameDeveloperUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload>
        }
        deleteMany: {
          args: Prisma.GameDeveloperDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GameDeveloperUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GameDeveloperUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload>[]
        }
        upsert: {
          args: Prisma.GameDeveloperUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameDeveloperPayload>
        }
        aggregate: {
          args: Prisma.GameDeveloperAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGameDeveloper>
        }
        groupBy: {
          args: Prisma.GameDeveloperGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GameDeveloperGroupByOutputType>[]
        }
        count: {
          args: Prisma.GameDeveloperCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GameDeveloperCountAggregateOutputType> | number
        }
      }
    }
    GameRule: {
      payload: Prisma.$GameRulePayload<ExtArgs>
      fields: Prisma.GameRuleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GameRuleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GameRuleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload>
        }
        findFirst: {
          args: Prisma.GameRuleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GameRuleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload>
        }
        findMany: {
          args: Prisma.GameRuleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload>[]
        }
        create: {
          args: Prisma.GameRuleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload>
        }
        createMany: {
          args: Prisma.GameRuleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GameRuleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload>[]
        }
        delete: {
          args: Prisma.GameRuleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload>
        }
        update: {
          args: Prisma.GameRuleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload>
        }
        deleteMany: {
          args: Prisma.GameRuleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GameRuleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GameRuleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload>[]
        }
        upsert: {
          args: Prisma.GameRuleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GameRulePayload>
        }
        aggregate: {
          args: Prisma.GameRuleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGameRule>
        }
        groupBy: {
          args: Prisma.GameRuleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GameRuleGroupByOutputType>[]
        }
        count: {
          args: Prisma.GameRuleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GameRuleCountAggregateOutputType> | number
        }
      }
    }
    GrandLaunchingRegistration: {
      payload: Prisma.$GrandLaunchingRegistrationPayload<ExtArgs>
      fields: Prisma.GrandLaunchingRegistrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GrandLaunchingRegistrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GrandLaunchingRegistrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload>
        }
        findFirst: {
          args: Prisma.GrandLaunchingRegistrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GrandLaunchingRegistrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload>
        }
        findMany: {
          args: Prisma.GrandLaunchingRegistrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload>[]
        }
        create: {
          args: Prisma.GrandLaunchingRegistrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload>
        }
        createMany: {
          args: Prisma.GrandLaunchingRegistrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GrandLaunchingRegistrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload>[]
        }
        delete: {
          args: Prisma.GrandLaunchingRegistrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload>
        }
        update: {
          args: Prisma.GrandLaunchingRegistrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload>
        }
        deleteMany: {
          args: Prisma.GrandLaunchingRegistrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GrandLaunchingRegistrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GrandLaunchingRegistrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload>[]
        }
        upsert: {
          args: Prisma.GrandLaunchingRegistrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrandLaunchingRegistrationPayload>
        }
        aggregate: {
          args: Prisma.GrandLaunchingRegistrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGrandLaunchingRegistration>
        }
        groupBy: {
          args: Prisma.GrandLaunchingRegistrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GrandLaunchingRegistrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.GrandLaunchingRegistrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GrandLaunchingRegistrationCountAggregateOutputType> | number
        }
      }
    }
    LeaderBoardHistory: {
      payload: Prisma.$LeaderBoardHistoryPayload<ExtArgs>
      fields: Prisma.LeaderBoardHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeaderBoardHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeaderBoardHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload>
        }
        findFirst: {
          args: Prisma.LeaderBoardHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeaderBoardHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload>
        }
        findMany: {
          args: Prisma.LeaderBoardHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload>[]
        }
        create: {
          args: Prisma.LeaderBoardHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload>
        }
        createMany: {
          args: Prisma.LeaderBoardHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeaderBoardHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload>[]
        }
        delete: {
          args: Prisma.LeaderBoardHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload>
        }
        update: {
          args: Prisma.LeaderBoardHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload>
        }
        deleteMany: {
          args: Prisma.LeaderBoardHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeaderBoardHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeaderBoardHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload>[]
        }
        upsert: {
          args: Prisma.LeaderBoardHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderBoardHistoryPayload>
        }
        aggregate: {
          args: Prisma.LeaderBoardHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeaderBoardHistory>
        }
        groupBy: {
          args: Prisma.LeaderBoardHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaderBoardHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeaderBoardHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaderBoardHistoryCountAggregateOutputType> | number
        }
      }
    }
    Member: {
      payload: Prisma.$MemberPayload<ExtArgs>
      fields: Prisma.MemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        findFirst: {
          args: Prisma.MemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        findMany: {
          args: Prisma.MemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>[]
        }
        create: {
          args: Prisma.MemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        createMany: {
          args: Prisma.MemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>[]
        }
        delete: {
          args: Prisma.MemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        update: {
          args: Prisma.MemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        deleteMany: {
          args: Prisma.MemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>[]
        }
        upsert: {
          args: Prisma.MemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        aggregate: {
          args: Prisma.MemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMember>
        }
        groupBy: {
          args: Prisma.MemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberCountAggregateOutputType> | number
        }
      }
    }
    MiniQuiz: {
      payload: Prisma.$MiniQuizPayload<ExtArgs>
      fields: Prisma.MiniQuizFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MiniQuizFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MiniQuizFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload>
        }
        findFirst: {
          args: Prisma.MiniQuizFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MiniQuizFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload>
        }
        findMany: {
          args: Prisma.MiniQuizFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload>[]
        }
        create: {
          args: Prisma.MiniQuizCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload>
        }
        createMany: {
          args: Prisma.MiniQuizCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MiniQuizCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload>[]
        }
        delete: {
          args: Prisma.MiniQuizDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload>
        }
        update: {
          args: Prisma.MiniQuizUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload>
        }
        deleteMany: {
          args: Prisma.MiniQuizDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MiniQuizUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MiniQuizUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload>[]
        }
        upsert: {
          args: Prisma.MiniQuizUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizPayload>
        }
        aggregate: {
          args: Prisma.MiniQuizAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMiniQuiz>
        }
        groupBy: {
          args: Prisma.MiniQuizGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MiniQuizGroupByOutputType>[]
        }
        count: {
          args: Prisma.MiniQuizCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MiniQuizCountAggregateOutputType> | number
        }
      }
    }
    MiniQuizAttempt: {
      payload: Prisma.$MiniQuizAttemptPayload<ExtArgs>
      fields: Prisma.MiniQuizAttemptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MiniQuizAttemptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MiniQuizAttemptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload>
        }
        findFirst: {
          args: Prisma.MiniQuizAttemptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MiniQuizAttemptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload>
        }
        findMany: {
          args: Prisma.MiniQuizAttemptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload>[]
        }
        create: {
          args: Prisma.MiniQuizAttemptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload>
        }
        createMany: {
          args: Prisma.MiniQuizAttemptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MiniQuizAttemptCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload>[]
        }
        delete: {
          args: Prisma.MiniQuizAttemptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload>
        }
        update: {
          args: Prisma.MiniQuizAttemptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload>
        }
        deleteMany: {
          args: Prisma.MiniQuizAttemptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MiniQuizAttemptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MiniQuizAttemptUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload>[]
        }
        upsert: {
          args: Prisma.MiniQuizAttemptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizAttemptPayload>
        }
        aggregate: {
          args: Prisma.MiniQuizAttemptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMiniQuizAttempt>
        }
        groupBy: {
          args: Prisma.MiniQuizAttemptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MiniQuizAttemptGroupByOutputType>[]
        }
        count: {
          args: Prisma.MiniQuizAttemptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MiniQuizAttemptCountAggregateOutputType> | number
        }
      }
    }
    MiniQuizQuestion: {
      payload: Prisma.$MiniQuizQuestionPayload<ExtArgs>
      fields: Prisma.MiniQuizQuestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MiniQuizQuestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MiniQuizQuestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload>
        }
        findFirst: {
          args: Prisma.MiniQuizQuestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MiniQuizQuestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload>
        }
        findMany: {
          args: Prisma.MiniQuizQuestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload>[]
        }
        create: {
          args: Prisma.MiniQuizQuestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload>
        }
        createMany: {
          args: Prisma.MiniQuizQuestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MiniQuizQuestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload>[]
        }
        delete: {
          args: Prisma.MiniQuizQuestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload>
        }
        update: {
          args: Prisma.MiniQuizQuestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload>
        }
        deleteMany: {
          args: Prisma.MiniQuizQuestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MiniQuizQuestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MiniQuizQuestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload>[]
        }
        upsert: {
          args: Prisma.MiniQuizQuestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MiniQuizQuestionPayload>
        }
        aggregate: {
          args: Prisma.MiniQuizQuestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMiniQuizQuestion>
        }
        groupBy: {
          args: Prisma.MiniQuizQuestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MiniQuizQuestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.MiniQuizQuestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MiniQuizQuestionCountAggregateOutputType> | number
        }
      }
    }
    Nominee: {
      payload: Prisma.$NomineePayload<ExtArgs>
      fields: Prisma.NomineeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NomineeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NomineeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload>
        }
        findFirst: {
          args: Prisma.NomineeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NomineeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload>
        }
        findMany: {
          args: Prisma.NomineeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload>[]
        }
        create: {
          args: Prisma.NomineeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload>
        }
        createMany: {
          args: Prisma.NomineeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NomineeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload>[]
        }
        delete: {
          args: Prisma.NomineeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload>
        }
        update: {
          args: Prisma.NomineeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload>
        }
        deleteMany: {
          args: Prisma.NomineeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NomineeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NomineeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload>[]
        }
        upsert: {
          args: Prisma.NomineeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineePayload>
        }
        aggregate: {
          args: Prisma.NomineeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNominee>
        }
        groupBy: {
          args: Prisma.NomineeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NomineeGroupByOutputType>[]
        }
        count: {
          args: Prisma.NomineeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NomineeCountAggregateOutputType> | number
        }
      }
    }
    NomineeVote: {
      payload: Prisma.$NomineeVotePayload<ExtArgs>
      fields: Prisma.NomineeVoteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NomineeVoteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NomineeVoteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload>
        }
        findFirst: {
          args: Prisma.NomineeVoteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NomineeVoteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload>
        }
        findMany: {
          args: Prisma.NomineeVoteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload>[]
        }
        create: {
          args: Prisma.NomineeVoteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload>
        }
        createMany: {
          args: Prisma.NomineeVoteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NomineeVoteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload>[]
        }
        delete: {
          args: Prisma.NomineeVoteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload>
        }
        update: {
          args: Prisma.NomineeVoteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload>
        }
        deleteMany: {
          args: Prisma.NomineeVoteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NomineeVoteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NomineeVoteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload>[]
        }
        upsert: {
          args: Prisma.NomineeVoteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NomineeVotePayload>
        }
        aggregate: {
          args: Prisma.NomineeVoteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNomineeVote>
        }
        groupBy: {
          args: Prisma.NomineeVoteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NomineeVoteGroupByOutputType>[]
        }
        count: {
          args: Prisma.NomineeVoteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NomineeVoteCountAggregateOutputType> | number
        }
      }
    }
    PlaygroundExpenseHistory: {
      payload: Prisma.$PlaygroundExpenseHistoryPayload<ExtArgs>
      fields: Prisma.PlaygroundExpenseHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PlaygroundExpenseHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PlaygroundExpenseHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload>
        }
        findFirst: {
          args: Prisma.PlaygroundExpenseHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PlaygroundExpenseHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload>
        }
        findMany: {
          args: Prisma.PlaygroundExpenseHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload>[]
        }
        create: {
          args: Prisma.PlaygroundExpenseHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload>
        }
        createMany: {
          args: Prisma.PlaygroundExpenseHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PlaygroundExpenseHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload>[]
        }
        delete: {
          args: Prisma.PlaygroundExpenseHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload>
        }
        update: {
          args: Prisma.PlaygroundExpenseHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload>
        }
        deleteMany: {
          args: Prisma.PlaygroundExpenseHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PlaygroundExpenseHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PlaygroundExpenseHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload>[]
        }
        upsert: {
          args: Prisma.PlaygroundExpenseHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundExpenseHistoryPayload>
        }
        aggregate: {
          args: Prisma.PlaygroundExpenseHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePlaygroundExpenseHistory>
        }
        groupBy: {
          args: Prisma.PlaygroundExpenseHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlaygroundExpenseHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.PlaygroundExpenseHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlaygroundExpenseHistoryCountAggregateOutputType> | number
        }
      }
    }
    PlaygroundRewardHistory: {
      payload: Prisma.$PlaygroundRewardHistoryPayload<ExtArgs>
      fields: Prisma.PlaygroundRewardHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PlaygroundRewardHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PlaygroundRewardHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload>
        }
        findFirst: {
          args: Prisma.PlaygroundRewardHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PlaygroundRewardHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload>
        }
        findMany: {
          args: Prisma.PlaygroundRewardHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload>[]
        }
        create: {
          args: Prisma.PlaygroundRewardHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload>
        }
        createMany: {
          args: Prisma.PlaygroundRewardHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PlaygroundRewardHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload>[]
        }
        delete: {
          args: Prisma.PlaygroundRewardHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload>
        }
        update: {
          args: Prisma.PlaygroundRewardHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload>
        }
        deleteMany: {
          args: Prisma.PlaygroundRewardHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PlaygroundRewardHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PlaygroundRewardHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload>[]
        }
        upsert: {
          args: Prisma.PlaygroundRewardHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundRewardHistoryPayload>
        }
        aggregate: {
          args: Prisma.PlaygroundRewardHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePlaygroundRewardHistory>
        }
        groupBy: {
          args: Prisma.PlaygroundRewardHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlaygroundRewardHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.PlaygroundRewardHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlaygroundRewardHistoryCountAggregateOutputType> | number
        }
      }
    }
    PlaygroundToken: {
      payload: Prisma.$PlaygroundTokenPayload<ExtArgs>
      fields: Prisma.PlaygroundTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PlaygroundTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PlaygroundTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload>
        }
        findFirst: {
          args: Prisma.PlaygroundTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PlaygroundTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload>
        }
        findMany: {
          args: Prisma.PlaygroundTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload>[]
        }
        create: {
          args: Prisma.PlaygroundTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload>
        }
        createMany: {
          args: Prisma.PlaygroundTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PlaygroundTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload>[]
        }
        delete: {
          args: Prisma.PlaygroundTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload>
        }
        update: {
          args: Prisma.PlaygroundTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload>
        }
        deleteMany: {
          args: Prisma.PlaygroundTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PlaygroundTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PlaygroundTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload>[]
        }
        upsert: {
          args: Prisma.PlaygroundTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlaygroundTokenPayload>
        }
        aggregate: {
          args: Prisma.PlaygroundTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePlaygroundToken>
        }
        groupBy: {
          args: Prisma.PlaygroundTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlaygroundTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.PlaygroundTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlaygroundTokenCountAggregateOutputType> | number
        }
      }
    }
    Program: {
      payload: Prisma.$ProgramPayload<ExtArgs>
      fields: Prisma.ProgramFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        findFirst: {
          args: Prisma.ProgramFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        findMany: {
          args: Prisma.ProgramFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>[]
        }
        create: {
          args: Prisma.ProgramCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        createMany: {
          args: Prisma.ProgramCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>[]
        }
        delete: {
          args: Prisma.ProgramDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        update: {
          args: Prisma.ProgramUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        deleteMany: {
          args: Prisma.ProgramDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>[]
        }
        upsert: {
          args: Prisma.ProgramUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        aggregate: {
          args: Prisma.ProgramAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgram>
        }
        groupBy: {
          args: Prisma.ProgramGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramCountAggregateOutputType> | number
        }
      }
    }
    ProgramRegistration: {
      payload: Prisma.$ProgramRegistrationPayload<ExtArgs>
      fields: Prisma.ProgramRegistrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramRegistrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramRegistrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload>
        }
        findFirst: {
          args: Prisma.ProgramRegistrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramRegistrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload>
        }
        findMany: {
          args: Prisma.ProgramRegistrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload>[]
        }
        create: {
          args: Prisma.ProgramRegistrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload>
        }
        createMany: {
          args: Prisma.ProgramRegistrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgramRegistrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload>[]
        }
        delete: {
          args: Prisma.ProgramRegistrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload>
        }
        update: {
          args: Prisma.ProgramRegistrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload>
        }
        deleteMany: {
          args: Prisma.ProgramRegistrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramRegistrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgramRegistrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload>[]
        }
        upsert: {
          args: Prisma.ProgramRegistrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramRegistrationPayload>
        }
        aggregate: {
          args: Prisma.ProgramRegistrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramRegistration>
        }
        groupBy: {
          args: Prisma.ProgramRegistrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramRegistrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramRegistrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramRegistrationCountAggregateOutputType> | number
        }
      }
    }
    ProgramTask: {
      payload: Prisma.$ProgramTaskPayload<ExtArgs>
      fields: Prisma.ProgramTaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramTaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramTaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload>
        }
        findFirst: {
          args: Prisma.ProgramTaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramTaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload>
        }
        findMany: {
          args: Prisma.ProgramTaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload>[]
        }
        create: {
          args: Prisma.ProgramTaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload>
        }
        createMany: {
          args: Prisma.ProgramTaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgramTaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload>[]
        }
        delete: {
          args: Prisma.ProgramTaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload>
        }
        update: {
          args: Prisma.ProgramTaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload>
        }
        deleteMany: {
          args: Prisma.ProgramTaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramTaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgramTaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload>[]
        }
        upsert: {
          args: Prisma.ProgramTaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskPayload>
        }
        aggregate: {
          args: Prisma.ProgramTaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramTask>
        }
        groupBy: {
          args: Prisma.ProgramTaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramTaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramTaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramTaskCountAggregateOutputType> | number
        }
      }
    }
    ProgramTaskExtraDescription: {
      payload: Prisma.$ProgramTaskExtraDescriptionPayload<ExtArgs>
      fields: Prisma.ProgramTaskExtraDescriptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramTaskExtraDescriptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramTaskExtraDescriptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload>
        }
        findFirst: {
          args: Prisma.ProgramTaskExtraDescriptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramTaskExtraDescriptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload>
        }
        findMany: {
          args: Prisma.ProgramTaskExtraDescriptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload>[]
        }
        create: {
          args: Prisma.ProgramTaskExtraDescriptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload>
        }
        createMany: {
          args: Prisma.ProgramTaskExtraDescriptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgramTaskExtraDescriptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload>[]
        }
        delete: {
          args: Prisma.ProgramTaskExtraDescriptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload>
        }
        update: {
          args: Prisma.ProgramTaskExtraDescriptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload>
        }
        deleteMany: {
          args: Prisma.ProgramTaskExtraDescriptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramTaskExtraDescriptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgramTaskExtraDescriptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload>[]
        }
        upsert: {
          args: Prisma.ProgramTaskExtraDescriptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskExtraDescriptionPayload>
        }
        aggregate: {
          args: Prisma.ProgramTaskExtraDescriptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramTaskExtraDescription>
        }
        groupBy: {
          args: Prisma.ProgramTaskExtraDescriptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramTaskExtraDescriptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramTaskExtraDescriptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramTaskExtraDescriptionCountAggregateOutputType> | number
        }
      }
    }
    ProgramTaskSubmission: {
      payload: Prisma.$ProgramTaskSubmissionPayload<ExtArgs>
      fields: Prisma.ProgramTaskSubmissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramTaskSubmissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramTaskSubmissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload>
        }
        findFirst: {
          args: Prisma.ProgramTaskSubmissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramTaskSubmissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload>
        }
        findMany: {
          args: Prisma.ProgramTaskSubmissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload>[]
        }
        create: {
          args: Prisma.ProgramTaskSubmissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload>
        }
        createMany: {
          args: Prisma.ProgramTaskSubmissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgramTaskSubmissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload>[]
        }
        delete: {
          args: Prisma.ProgramTaskSubmissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload>
        }
        update: {
          args: Prisma.ProgramTaskSubmissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload>
        }
        deleteMany: {
          args: Prisma.ProgramTaskSubmissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramTaskSubmissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgramTaskSubmissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload>[]
        }
        upsert: {
          args: Prisma.ProgramTaskSubmissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramTaskSubmissionPayload>
        }
        aggregate: {
          args: Prisma.ProgramTaskSubmissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramTaskSubmission>
        }
        groupBy: {
          args: Prisma.ProgramTaskSubmissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramTaskSubmissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramTaskSubmissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramTaskSubmissionCountAggregateOutputType> | number
        }
      }
    }
    Project: {
      payload: Prisma.$ProjectPayload<ExtArgs>
      fields: Prisma.ProjectFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findFirst: {
          args: Prisma.ProjectFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findMany: {
          args: Prisma.ProjectFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        create: {
          args: Prisma.ProjectCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        createMany: {
          args: Prisma.ProjectCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        delete: {
          args: Prisma.ProjectDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        update: {
          args: Prisma.ProjectUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        deleteMany: {
          args: Prisma.ProjectDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        upsert: {
          args: Prisma.ProjectUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        aggregate: {
          args: Prisma.ProjectAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProject>
        }
        groupBy: {
          args: Prisma.ProjectGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectCountAggregateOutputType> | number
        }
      }
    }
    ReferalCodeUsage: {
      payload: Prisma.$ReferalCodeUsagePayload<ExtArgs>
      fields: Prisma.ReferalCodeUsageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReferalCodeUsageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReferalCodeUsageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload>
        }
        findFirst: {
          args: Prisma.ReferalCodeUsageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReferalCodeUsageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload>
        }
        findMany: {
          args: Prisma.ReferalCodeUsageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload>[]
        }
        create: {
          args: Prisma.ReferalCodeUsageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload>
        }
        createMany: {
          args: Prisma.ReferalCodeUsageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReferalCodeUsageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload>[]
        }
        delete: {
          args: Prisma.ReferalCodeUsageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload>
        }
        update: {
          args: Prisma.ReferalCodeUsageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload>
        }
        deleteMany: {
          args: Prisma.ReferalCodeUsageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReferalCodeUsageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReferalCodeUsageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload>[]
        }
        upsert: {
          args: Prisma.ReferalCodeUsageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReferalCodeUsagePayload>
        }
        aggregate: {
          args: Prisma.ReferalCodeUsageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReferalCodeUsage>
        }
        groupBy: {
          args: Prisma.ReferalCodeUsageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReferalCodeUsageGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReferalCodeUsageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReferalCodeUsageCountAggregateOutputType> | number
        }
      }
    }
    SingleParticipant: {
      payload: Prisma.$SingleParticipantPayload<ExtArgs>
      fields: Prisma.SingleParticipantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SingleParticipantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SingleParticipantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload>
        }
        findFirst: {
          args: Prisma.SingleParticipantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SingleParticipantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload>
        }
        findMany: {
          args: Prisma.SingleParticipantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload>[]
        }
        create: {
          args: Prisma.SingleParticipantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload>
        }
        createMany: {
          args: Prisma.SingleParticipantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SingleParticipantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload>[]
        }
        delete: {
          args: Prisma.SingleParticipantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload>
        }
        update: {
          args: Prisma.SingleParticipantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload>
        }
        deleteMany: {
          args: Prisma.SingleParticipantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SingleParticipantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SingleParticipantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload>[]
        }
        upsert: {
          args: Prisma.SingleParticipantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SingleParticipantPayload>
        }
        aggregate: {
          args: Prisma.SingleParticipantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSingleParticipant>
        }
        groupBy: {
          args: Prisma.SingleParticipantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SingleParticipantGroupByOutputType>[]
        }
        count: {
          args: Prisma.SingleParticipantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SingleParticipantCountAggregateOutputType> | number
        }
      }
    }
    Team: {
      payload: Prisma.$TeamPayload<ExtArgs>
      fields: Prisma.TeamFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TeamFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        findFirst: {
          args: Prisma.TeamFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        findMany: {
          args: Prisma.TeamFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[]
        }
        create: {
          args: Prisma.TeamCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        createMany: {
          args: Prisma.TeamCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[]
        }
        delete: {
          args: Prisma.TeamDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        update: {
          args: Prisma.TeamUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        deleteMany: {
          args: Prisma.TeamDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TeamUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[]
        }
        upsert: {
          args: Prisma.TeamUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>
        }
        aggregate: {
          args: Prisma.TeamAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeam>
        }
        groupBy: {
          args: Prisma.TeamGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TeamGroupByOutputType>[]
        }
        count: {
          args: Prisma.TeamCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TeamCountAggregateOutputType> | number
        }
      }
    }
    UserData: {
      payload: Prisma.$UserDataPayload<ExtArgs>
      fields: Prisma.UserDataFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserDataFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserDataFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        findFirst: {
          args: Prisma.UserDataFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserDataFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        findMany: {
          args: Prisma.UserDataFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>[]
        }
        create: {
          args: Prisma.UserDataCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        createMany: {
          args: Prisma.UserDataCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserDataCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>[]
        }
        delete: {
          args: Prisma.UserDataDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        update: {
          args: Prisma.UserDataUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        deleteMany: {
          args: Prisma.UserDataDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserDataUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserDataUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>[]
        }
        upsert: {
          args: Prisma.UserDataUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        aggregate: {
          args: Prisma.UserDataAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserData>
        }
        groupBy: {
          args: Prisma.UserDataGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserDataGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserDataCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserDataCountAggregateOutputType> | number
        }
      }
    }
    UserPlayGameHistory: {
      payload: Prisma.$UserPlayGameHistoryPayload<ExtArgs>
      fields: Prisma.UserPlayGameHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserPlayGameHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserPlayGameHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload>
        }
        findFirst: {
          args: Prisma.UserPlayGameHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserPlayGameHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload>
        }
        findMany: {
          args: Prisma.UserPlayGameHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload>[]
        }
        create: {
          args: Prisma.UserPlayGameHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload>
        }
        createMany: {
          args: Prisma.UserPlayGameHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserPlayGameHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload>[]
        }
        delete: {
          args: Prisma.UserPlayGameHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload>
        }
        update: {
          args: Prisma.UserPlayGameHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload>
        }
        deleteMany: {
          args: Prisma.UserPlayGameHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserPlayGameHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserPlayGameHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload>[]
        }
        upsert: {
          args: Prisma.UserPlayGameHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlayGameHistoryPayload>
        }
        aggregate: {
          args: Prisma.UserPlayGameHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserPlayGameHistory>
        }
        groupBy: {
          args: Prisma.UserPlayGameHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPlayGameHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserPlayGameHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPlayGameHistoryCountAggregateOutputType> | number
        }
      }
    }
    UserPlayground: {
      payload: Prisma.$UserPlaygroundPayload<ExtArgs>
      fields: Prisma.UserPlaygroundFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserPlaygroundFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserPlaygroundFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload>
        }
        findFirst: {
          args: Prisma.UserPlaygroundFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserPlaygroundFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload>
        }
        findMany: {
          args: Prisma.UserPlaygroundFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload>[]
        }
        create: {
          args: Prisma.UserPlaygroundCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload>
        }
        createMany: {
          args: Prisma.UserPlaygroundCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserPlaygroundCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload>[]
        }
        delete: {
          args: Prisma.UserPlaygroundDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload>
        }
        update: {
          args: Prisma.UserPlaygroundUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload>
        }
        deleteMany: {
          args: Prisma.UserPlaygroundDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserPlaygroundUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserPlaygroundUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload>[]
        }
        upsert: {
          args: Prisma.UserPlaygroundUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundPayload>
        }
        aggregate: {
          args: Prisma.UserPlaygroundAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserPlayground>
        }
        groupBy: {
          args: Prisma.UserPlaygroundGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPlaygroundGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserPlaygroundCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPlaygroundCountAggregateOutputType> | number
        }
      }
    }
    UserPlaygroundDetention: {
      payload: Prisma.$UserPlaygroundDetentionPayload<ExtArgs>
      fields: Prisma.UserPlaygroundDetentionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserPlaygroundDetentionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserPlaygroundDetentionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload>
        }
        findFirst: {
          args: Prisma.UserPlaygroundDetentionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserPlaygroundDetentionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload>
        }
        findMany: {
          args: Prisma.UserPlaygroundDetentionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload>[]
        }
        create: {
          args: Prisma.UserPlaygroundDetentionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload>
        }
        createMany: {
          args: Prisma.UserPlaygroundDetentionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserPlaygroundDetentionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload>[]
        }
        delete: {
          args: Prisma.UserPlaygroundDetentionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload>
        }
        update: {
          args: Prisma.UserPlaygroundDetentionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload>
        }
        deleteMany: {
          args: Prisma.UserPlaygroundDetentionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserPlaygroundDetentionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserPlaygroundDetentionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload>[]
        }
        upsert: {
          args: Prisma.UserPlaygroundDetentionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlaygroundDetentionPayload>
        }
        aggregate: {
          args: Prisma.UserPlaygroundDetentionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserPlaygroundDetention>
        }
        groupBy: {
          args: Prisma.UserPlaygroundDetentionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPlaygroundDetentionGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserPlaygroundDetentionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPlaygroundDetentionCountAggregateOutputType> | number
        }
      }
    }
    account: {
      payload: Prisma.$accountPayload<ExtArgs>
      fields: Prisma.accountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.accountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.accountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>
        }
        findFirst: {
          args: Prisma.accountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.accountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>
        }
        findMany: {
          args: Prisma.accountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>[]
        }
        create: {
          args: Prisma.accountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>
        }
        createMany: {
          args: Prisma.accountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.accountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>[]
        }
        delete: {
          args: Prisma.accountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>
        }
        update: {
          args: Prisma.accountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>
        }
        deleteMany: {
          args: Prisma.accountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.accountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.accountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>[]
        }
        upsert: {
          args: Prisma.accountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$accountPayload>
        }
        aggregate: {
          args: Prisma.AccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>
        }
        groupBy: {
          args: Prisma.accountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.accountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number
        }
      }
    }
    rateLimit: {
      payload: Prisma.$rateLimitPayload<ExtArgs>
      fields: Prisma.rateLimitFieldRefs
      operations: {
        findUnique: {
          args: Prisma.rateLimitFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.rateLimitFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload>
        }
        findFirst: {
          args: Prisma.rateLimitFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.rateLimitFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload>
        }
        findMany: {
          args: Prisma.rateLimitFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload>[]
        }
        create: {
          args: Prisma.rateLimitCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload>
        }
        createMany: {
          args: Prisma.rateLimitCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.rateLimitCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload>[]
        }
        delete: {
          args: Prisma.rateLimitDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload>
        }
        update: {
          args: Prisma.rateLimitUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload>
        }
        deleteMany: {
          args: Prisma.rateLimitDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.rateLimitUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.rateLimitUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload>[]
        }
        upsert: {
          args: Prisma.rateLimitUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rateLimitPayload>
        }
        aggregate: {
          args: Prisma.RateLimitAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRateLimit>
        }
        groupBy: {
          args: Prisma.rateLimitGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RateLimitGroupByOutputType>[]
        }
        count: {
          args: Prisma.rateLimitCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RateLimitCountAggregateOutputType> | number
        }
      }
    }
    session: {
      payload: Prisma.$sessionPayload<ExtArgs>
      fields: Prisma.sessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.sessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        findFirst: {
          args: Prisma.sessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        findMany: {
          args: Prisma.sessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>[]
        }
        create: {
          args: Prisma.sessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        createMany: {
          args: Prisma.sessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.sessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>[]
        }
        delete: {
          args: Prisma.sessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        update: {
          args: Prisma.sessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        deleteMany: {
          args: Prisma.sessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.sessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.sessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>[]
        }
        upsert: {
          args: Prisma.sessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.sessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.sessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    user: {
      payload: Prisma.$userPayload<ExtArgs>
      fields: Prisma.userFieldRefs
      operations: {
        findUnique: {
          args: Prisma.userFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        findFirst: {
          args: Prisma.userFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        findMany: {
          args: Prisma.userFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>[]
        }
        create: {
          args: Prisma.userCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        createMany: {
          args: Prisma.userCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>[]
        }
        delete: {
          args: Prisma.userDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        update: {
          args: Prisma.userUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        deleteMany: {
          args: Prisma.userDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.userUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>[]
        }
        upsert: {
          args: Prisma.userUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$userPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.userGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.userCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    verification: {
      payload: Prisma.$verificationPayload<ExtArgs>
      fields: Prisma.verificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.verificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.verificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>
        }
        findFirst: {
          args: Prisma.verificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.verificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>
        }
        findMany: {
          args: Prisma.verificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>[]
        }
        create: {
          args: Prisma.verificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>
        }
        createMany: {
          args: Prisma.verificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.verificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>[]
        }
        delete: {
          args: Prisma.verificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>
        }
        update: {
          args: Prisma.verificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>
        }
        deleteMany: {
          args: Prisma.verificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.verificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.verificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>[]
        }
        upsert: {
          args: Prisma.verificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$verificationPayload>
        }
        aggregate: {
          args: Prisma.VerificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerification>
        }
        groupBy: {
          args: Prisma.verificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.verificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const AdWatchHistoryScalarFieldEnum = {
  id: 'id',
  userPlaygroundId: 'userPlaygroundId',
  adId: 'adId',
  watchedAt: 'watchedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AdWatchHistoryScalarFieldEnum = (typeof AdWatchHistoryScalarFieldEnum)[keyof typeof AdWatchHistoryScalarFieldEnum]


export const AdWatchSessionScalarFieldEnum = {
  id: 'id',
  userPlaygroundId: 'userPlaygroundId',
  adId: 'adId',
  adLength: 'adLength',
  startTimeUnix: 'startTimeUnix',
  lockUntil: 'lockUntil',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AdWatchSessionScalarFieldEnum = (typeof AdWatchSessionScalarFieldEnum)[keyof typeof AdWatchSessionScalarFieldEnum]


export const AdvertisementScalarFieldEnum = {
  id: 'id',
  contentUrl: 'contentUrl',
  isVideo: 'isVideo',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  contentLength: 'contentLength'
} as const

export type AdvertisementScalarFieldEnum = (typeof AdvertisementScalarFieldEnum)[keyof typeof AdvertisementScalarFieldEnum]


export const AnnouncementScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  programId: 'programId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


export const ArticleScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  url: 'url',
  imageUrl: 'imageUrl'
} as const

export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


export const CVClinicClaimScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  status: 'status',
  usedVoucherCode: 'usedVoucherCode',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CVClinicClaimScalarFieldEnum = (typeof CVClinicClaimScalarFieldEnum)[keyof typeof CVClinicClaimScalarFieldEnum]


export const CVClinicVouchersScalarFieldEnum = {
  code: 'code'
} as const

export type CVClinicVouchersScalarFieldEnum = (typeof CVClinicVouchersScalarFieldEnum)[keyof typeof CVClinicVouchersScalarFieldEnum]


export const DashboardNotificationScalarFieldEnum = {
  id: 'id',
  title: 'title',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  content: 'content',
  isPrivate: 'isPrivate',
  type: 'type'
} as const

export type DashboardNotificationScalarFieldEnum = (typeof DashboardNotificationScalarFieldEnum)[keyof typeof DashboardNotificationScalarFieldEnum]


export const DashboardNotificationUserReadScalarFieldEnum = {
  id: 'id',
  isOpened: 'isOpened',
  userId: 'userId',
  notificationId: 'notificationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DashboardNotificationUserReadScalarFieldEnum = (typeof DashboardNotificationUserReadScalarFieldEnum)[keyof typeof DashboardNotificationUserReadScalarFieldEnum]


export const EventScalarFieldEnum = {
  id: 'id',
  name: 'name',
  createdAt: 'createdAt',
  eventType: 'eventType',
  updatedAt: 'updatedAt',
  description: 'description'
} as const

export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


export const EventDateScalarFieldEnum = {
  id: 'id',
  name: 'name',
  eventId: 'eventId',
  endDate: 'endDate',
  startDate: 'startDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  description: 'description'
} as const

export type EventDateScalarFieldEnum = (typeof EventDateScalarFieldEnum)[keyof typeof EventDateScalarFieldEnum]


export const EventRegistrationScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventRegistrationScalarFieldEnum = (typeof EventRegistrationScalarFieldEnum)[keyof typeof EventRegistrationScalarFieldEnum]


export const ExhibitorScalarFieldEnum = {
  id: 'id',
  companyName: 'companyName',
  name: 'name',
  email: 'email',
  phoneNumber: 'phoneNumber',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ExhibitorScalarFieldEnum = (typeof ExhibitorScalarFieldEnum)[keyof typeof ExhibitorScalarFieldEnum]


export const ExploreITFunfactScalarFieldEnum = {
  id: 'id',
  imageUrl: 'imageUrl',
  content: 'content',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  title: 'title'
} as const

export type ExploreITFunfactScalarFieldEnum = (typeof ExploreITFunfactScalarFieldEnum)[keyof typeof ExploreITFunfactScalarFieldEnum]


export const FeedbackScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  isOpen: 'isOpen'
} as const

export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


export const FeedbackOptionScalarFieldEnum = {
  id: 'id',
  questionId: 'questionId',
  stringAnswer: 'stringAnswer',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FeedbackOptionScalarFieldEnum = (typeof FeedbackOptionScalarFieldEnum)[keyof typeof FeedbackOptionScalarFieldEnum]


export const FeedbackQuestionScalarFieldEnum = {
  id: 'id',
  question: 'question',
  questionType: 'questionType',
  feedbackId: 'feedbackId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FeedbackQuestionScalarFieldEnum = (typeof FeedbackQuestionScalarFieldEnum)[keyof typeof FeedbackQuestionScalarFieldEnum]


export const FeedbackSubmissionScalarFieldEnum = {
  id: 'id',
  feedbackId: 'feedbackId',
  userId: 'userId',
  answerJson: 'answerJson',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FeedbackSubmissionScalarFieldEnum = (typeof FeedbackSubmissionScalarFieldEnum)[keyof typeof FeedbackSubmissionScalarFieldEnum]


export const GameScalarFieldEnum = {
  id: 'id',
  name: 'name',
  arcadeCode: 'arcadeCode',
  arcadeUrl: 'arcadeUrl',
  isGetPoint: 'isGetPoint',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  description: 'description',
  rules: 'rules',
  orientation: 'orientation'
} as const

export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


export const GameDeveloperScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  imageUrl: 'imageUrl',
  instagramUrl: 'instagramUrl',
  linkedInUrl: 'linkedInUrl',
  gameId: 'gameId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GameDeveloperScalarFieldEnum = (typeof GameDeveloperScalarFieldEnum)[keyof typeof GameDeveloperScalarFieldEnum]


export const GameRuleScalarFieldEnum = {
  id: 'id',
  gameId: 'gameId',
  title: 'title',
  rule: 'rule',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GameRuleScalarFieldEnum = (typeof GameRuleScalarFieldEnum)[keyof typeof GameRuleScalarFieldEnum]


export const GrandLaunchingRegistrationScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  knowEventSource: 'knowEventSource',
  eventRegistrationId: 'eventRegistrationId'
} as const

export type GrandLaunchingRegistrationScalarFieldEnum = (typeof GrandLaunchingRegistrationScalarFieldEnum)[keyof typeof GrandLaunchingRegistrationScalarFieldEnum]


export const LeaderBoardHistoryScalarFieldEnum = {
  id: 'id',
  jsonData: 'jsonData',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LeaderBoardHistoryScalarFieldEnum = (typeof LeaderBoardHistoryScalarFieldEnum)[keyof typeof LeaderBoardHistoryScalarFieldEnum]


export const MemberScalarFieldEnum = {
  id: 'id',
  isLeader: 'isLeader',
  userId: 'userId',
  teamId: 'teamId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


export const MiniQuizScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  quizName: 'quizName'
} as const

export type MiniQuizScalarFieldEnum = (typeof MiniQuizScalarFieldEnum)[keyof typeof MiniQuizScalarFieldEnum]


export const MiniQuizAttemptScalarFieldEnum = {
  id: 'id',
  quizId: 'quizId',
  userId: 'userId',
  answerJson: 'answerJson',
  attemptedAt: 'attemptedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MiniQuizAttemptScalarFieldEnum = (typeof MiniQuizAttemptScalarFieldEnum)[keyof typeof MiniQuizAttemptScalarFieldEnum]


export const MiniQuizQuestionScalarFieldEnum = {
  id: 'id',
  question: 'question',
  isTrue: 'isTrue',
  createdAt: 'createdAt',
  quizId: 'quizId',
  updatedAt: 'updatedAt'
} as const

export type MiniQuizQuestionScalarFieldEnum = (typeof MiniQuizQuestionScalarFieldEnum)[keyof typeof MiniQuizQuestionScalarFieldEnum]


export const NomineeScalarFieldEnum = {
  id: 'id',
  type: 'type',
  name: 'name',
  developer: 'developer',
  description: 'description',
  isActive: 'isActive',
  point: 'point',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  thumbnailUrl: 'thumbnailUrl',
  url: 'url'
} as const

export type NomineeScalarFieldEnum = (typeof NomineeScalarFieldEnum)[keyof typeof NomineeScalarFieldEnum]


export const NomineeVoteScalarFieldEnum = {
  id: 'id',
  type: 'type',
  firstChoiceNomineeId: 'firstChoiceNomineeId',
  secondChoiceNomineeId: 'secondChoiceNomineeId',
  thirdChoiceNomineeId: 'thirdChoiceNomineeId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NomineeVoteScalarFieldEnum = (typeof NomineeVoteScalarFieldEnum)[keyof typeof NomineeVoteScalarFieldEnum]


export const PlaygroundExpenseHistoryScalarFieldEnum = {
  id: 'id',
  userPlaygroundId: 'userPlaygroundId',
  description: 'description',
  amount: 'amount',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PlaygroundExpenseHistoryScalarFieldEnum = (typeof PlaygroundExpenseHistoryScalarFieldEnum)[keyof typeof PlaygroundExpenseHistoryScalarFieldEnum]


export const PlaygroundRewardHistoryScalarFieldEnum = {
  id: 'id',
  userPlaygroundId: 'userPlaygroundId',
  description: 'description',
  rewardType: 'rewardType',
  amount: 'amount',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PlaygroundRewardHistoryScalarFieldEnum = (typeof PlaygroundRewardHistoryScalarFieldEnum)[keyof typeof PlaygroundRewardHistoryScalarFieldEnum]


export const PlaygroundTokenScalarFieldEnum = {
  id: 'id',
  userPlaygroundId: 'userPlaygroundId',
  isUsed: 'isUsed',
  usedAt: 'usedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  expiredAt: 'expiredAt',
  tokenType: 'tokenType',
  code: 'code'
} as const

export type PlaygroundTokenScalarFieldEnum = (typeof PlaygroundTokenScalarFieldEnum)[keyof typeof PlaygroundTokenScalarFieldEnum]


export const ProgramScalarFieldEnum = {
  id: 'id',
  code: 'code',
  type: 'type',
  minAge: 'minAge',
  maxAge: 'maxAge',
  allowedEducationLevel: 'allowedEducationLevel',
  minMember: 'minMember',
  maxMember: 'maxMember',
  isAbleToRegisterAsTeam: 'isAbleToRegisterAsTeam',
  name: 'name',
  logoUrl: 'logoUrl',
  paymentBills: 'paymentBills',
  startDate: 'startDate',
  extendStartDate: 'extendStartDate',
  endDate: 'endDate',
  guideBookUrl: 'guideBookUrl',
  assignmentUrl: 'assignmentUrl',
  coordinationGroupUrl: 'coordinationGroupUrl',
  about: 'about',
  timeline: 'timeline',
  testimony: 'testimony',
  FAQ: 'FAQ',
  contactPerson: 'contactPerson',
  content: 'content',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


export const ProgramRegistrationScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProgramRegistrationScalarFieldEnum = (typeof ProgramRegistrationScalarFieldEnum)[keyof typeof ProgramRegistrationScalarFieldEnum]


export const ProgramTaskScalarFieldEnum = {
  id: 'id',
  title: 'title',
  deadline: 'deadline',
  description: 'description',
  guideBookUrl: 'guideBookUrl',
  type: 'type',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  acceptedFileTypes: 'acceptedFileTypes'
} as const

export type ProgramTaskScalarFieldEnum = (typeof ProgramTaskScalarFieldEnum)[keyof typeof ProgramTaskScalarFieldEnum]


export const ProgramTaskExtraDescriptionScalarFieldEnum = {
  id: 'id',
  taskId: 'taskId',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  forProgram: 'forProgram'
} as const

export type ProgramTaskExtraDescriptionScalarFieldEnum = (typeof ProgramTaskExtraDescriptionScalarFieldEnum)[keyof typeof ProgramTaskExtraDescriptionScalarFieldEnum]


export const ProgramTaskSubmissionScalarFieldEnum = {
  id: 'id',
  fileUrl: 'fileUrl',
  fileName: 'fileName',
  status: 'status',
  feedback: 'feedback',
  taskId: 'taskId',
  teamId: 'teamId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  submissionForProgram: 'submissionForProgram'
} as const

export type ProgramTaskSubmissionScalarFieldEnum = (typeof ProgramTaskSubmissionScalarFieldEnum)[keyof typeof ProgramTaskSubmissionScalarFieldEnum]


export const ProjectScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  imageUrl: 'imageUrl',
  description: 'description',
  youtubeUrl: 'youtubeUrl',
  teamName: 'teamName',
  votes: 'votes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


export const ReferalCodeUsageScalarFieldEnum = {
  id: 'id',
  provideById: 'provideById',
  usedById: 'usedById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  isValidated: 'isValidated'
} as const

export type ReferalCodeUsageScalarFieldEnum = (typeof ReferalCodeUsageScalarFieldEnum)[keyof typeof ReferalCodeUsageScalarFieldEnum]


export const SingleParticipantScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  programId: 'programId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SingleParticipantScalarFieldEnum = (typeof SingleParticipantScalarFieldEnum)[keyof typeof SingleParticipantScalarFieldEnum]


export const TeamScalarFieldEnum = {
  id: 'id',
  status: 'status',
  name: 'name',
  programId: 'programId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  code: 'code',
  notes: 'notes'
} as const

export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


export const UserDataScalarFieldEnum = {
  id: 'id',
  avatar: 'avatar',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  userId: 'userId',
  jobInstitution: 'jobInstitution',
  lineId: 'lineId',
  phoneNumber: 'phoneNumber',
  birthDate: 'birthDate',
  domicile: 'domicile',
  lastEducation: 'lastEducation',
  isBanned: 'isBanned',
  isStaff: 'isStaff',
  referalCode: 'referalCode',
  currentSemester: 'currentSemester',
  discordId: 'discordId'
} as const

export type UserDataScalarFieldEnum = (typeof UserDataScalarFieldEnum)[keyof typeof UserDataScalarFieldEnum]


export const UserPlayGameHistoryScalarFieldEnum = {
  id: 'id',
  userPlaygroundId: 'userPlaygroundId',
  gameId: 'gameId',
  tokenUsedId: 'tokenUsedId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  finishedAt: 'finishedAt',
  isFinished: 'isFinished'
} as const

export type UserPlayGameHistoryScalarFieldEnum = (typeof UserPlayGameHistoryScalarFieldEnum)[keyof typeof UserPlayGameHistoryScalarFieldEnum]


export const UserPlaygroundScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  username: 'username',
  virtualPoint: 'virtualPoint',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserPlaygroundScalarFieldEnum = (typeof UserPlaygroundScalarFieldEnum)[keyof typeof UserPlaygroundScalarFieldEnum]


export const UserPlaygroundDetentionScalarFieldEnum = {
  id: 'id',
  userPlaygroundId: 'userPlaygroundId',
  description: 'description',
  penaltyPoint: 'penaltyPoint',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  isRead: 'isRead',
  state: 'state'
} as const

export type UserPlaygroundDetentionScalarFieldEnum = (typeof UserPlaygroundDetentionScalarFieldEnum)[keyof typeof UserPlaygroundDetentionScalarFieldEnum]


export const AccountScalarFieldEnum = {
  id: 'id',
  scope: 'scope',
  password: 'password',
  accessToken: 'accessToken',
  accessTokenExpiresAt: 'accessTokenExpiresAt',
  accountId: 'accountId',
  createdAt: 'createdAt',
  idToken: 'idToken',
  providerId: 'providerId',
  refreshToken: 'refreshToken',
  refreshTokenExpiresAt: 'refreshTokenExpiresAt',
  updatedAt: 'updatedAt',
  userId: 'userId'
} as const

export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


export const RateLimitScalarFieldEnum = {
  id: 'id',
  key: 'key',
  count: 'count',
  lastRequest: 'lastRequest'
} as const

export type RateLimitScalarFieldEnum = (typeof RateLimitScalarFieldEnum)[keyof typeof RateLimitScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  token: 'token',
  createdAt: 'createdAt',
  expiresAt: 'expiresAt',
  ipAddress: 'ipAddress',
  updatedAt: 'updatedAt',
  userAgent: 'userAgent',
  userId: 'userId'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  image: 'image',
  name: 'name',
  emailVerified: 'emailVerified',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const VerificationScalarFieldEnum = {
  id: 'id',
  identifier: 'identifier',
  value: 'value',
  createdAt: 'createdAt',
  expiresAt: 'expiresAt',
  updatedAt: 'updatedAt'
} as const

export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references 
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'CV_STATUS'
 */
export type EnumCV_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CV_STATUS'>
    


/**
 * Reference to a field of type 'CV_STATUS[]'
 */
export type ListEnumCV_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CV_STATUS[]'>
    


/**
 * Reference to a field of type 'PROGRAM_CODE'
 */
export type EnumPROGRAM_CODEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PROGRAM_CODE'>
    


/**
 * Reference to a field of type 'PROGRAM_CODE[]'
 */
export type ListEnumPROGRAM_CODEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PROGRAM_CODE[]'>
    


/**
 * Reference to a field of type 'EVENT_TYPE'
 */
export type EnumEVENT_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EVENT_TYPE'>
    


/**
 * Reference to a field of type 'EVENT_TYPE[]'
 */
export type ListEnumEVENT_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EVENT_TYPE[]'>
    


/**
 * Reference to a field of type 'QuestionType'
 */
export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


/**
 * Reference to a field of type 'QuestionType[]'
 */
export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'GameOrientation'
 */
export type EnumGameOrientationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameOrientation'>
    


/**
 * Reference to a field of type 'GameOrientation[]'
 */
export type ListEnumGameOrientationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameOrientation[]'>
    


/**
 * Reference to a field of type 'KNOW_EVENT_SOURCE'
 */
export type EnumKNOW_EVENT_SOURCEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KNOW_EVENT_SOURCE'>
    


/**
 * Reference to a field of type 'KNOW_EVENT_SOURCE[]'
 */
export type ListEnumKNOW_EVENT_SOURCEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KNOW_EVENT_SOURCE[]'>
    


/**
 * Reference to a field of type 'NOMINEE_TYPE'
 */
export type EnumNOMINEE_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NOMINEE_TYPE'>
    


/**
 * Reference to a field of type 'NOMINEE_TYPE[]'
 */
export type ListEnumNOMINEE_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NOMINEE_TYPE[]'>
    


/**
 * Reference to a field of type 'RewardType'
 */
export type EnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardType'>
    


/**
 * Reference to a field of type 'RewardType[]'
 */
export type ListEnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardType[]'>
    


/**
 * Reference to a field of type 'TOKEN_TYPE'
 */
export type EnumTOKEN_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TOKEN_TYPE'>
    


/**
 * Reference to a field of type 'TOKEN_TYPE[]'
 */
export type ListEnumTOKEN_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TOKEN_TYPE[]'>
    


/**
 * Reference to a field of type 'PROGRAM_TYPE'
 */
export type EnumPROGRAM_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PROGRAM_TYPE'>
    


/**
 * Reference to a field of type 'PROGRAM_TYPE[]'
 */
export type ListEnumPROGRAM_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PROGRAM_TYPE[]'>
    


/**
 * Reference to a field of type 'Json[]'
 */
export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


/**
 * Reference to a field of type 'PROGRAM_TASK_TYPE'
 */
export type EnumPROGRAM_TASK_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PROGRAM_TASK_TYPE'>
    


/**
 * Reference to a field of type 'PROGRAM_TASK_TYPE[]'
 */
export type ListEnumPROGRAM_TASK_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PROGRAM_TASK_TYPE[]'>
    


/**
 * Reference to a field of type 'FILE_TYPE[]'
 */
export type ListEnumFILE_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FILE_TYPE[]'>
    


/**
 * Reference to a field of type 'FILE_TYPE'
 */
export type EnumFILE_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FILE_TYPE'>
    


/**
 * Reference to a field of type 'SUBMISSION_STATUS'
 */
export type EnumSUBMISSION_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SUBMISSION_STATUS'>
    


/**
 * Reference to a field of type 'SUBMISSION_STATUS[]'
 */
export type ListEnumSUBMISSION_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SUBMISSION_STATUS[]'>
    


/**
 * Reference to a field of type 'TEAM_STATUS'
 */
export type EnumTEAM_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TEAM_STATUS'>
    


/**
 * Reference to a field of type 'TEAM_STATUS[]'
 */
export type ListEnumTEAM_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TEAM_STATUS[]'>
    


/**
 * Reference to a field of type 'DETENTION_STATE'
 */
export type EnumDETENTION_STATEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DETENTION_STATE'>
    


/**
 * Reference to a field of type 'DETENTION_STATE[]'
 */
export type ListEnumDETENTION_STATEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DETENTION_STATE[]'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'BigInt[]'
 */
export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}


export type Datasource = {
  url?: string
}
export type Datasources = {
  db?: Datasource
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasources?: Datasources
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasourceUrl?: string
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *   { emit: 'stdout', level: 'query' },
   *   { emit: 'stdout', level: 'info' },
   *   { emit: 'stdout', level: 'warn' }
   *   { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  adWatchHistory?: Prisma.AdWatchHistoryOmit
  adWatchSession?: Prisma.AdWatchSessionOmit
  advertisement?: Prisma.AdvertisementOmit
  announcement?: Prisma.AnnouncementOmit
  article?: Prisma.ArticleOmit
  cVClinicClaim?: Prisma.CVClinicClaimOmit
  cVClinicVouchers?: Prisma.CVClinicVouchersOmit
  dashboardNotification?: Prisma.DashboardNotificationOmit
  dashboardNotificationUserRead?: Prisma.DashboardNotificationUserReadOmit
  event?: Prisma.EventOmit
  eventDate?: Prisma.EventDateOmit
  eventRegistration?: Prisma.EventRegistrationOmit
  exhibitor?: Prisma.ExhibitorOmit
  exploreITFunfact?: Prisma.ExploreITFunfactOmit
  feedback?: Prisma.FeedbackOmit
  feedbackOption?: Prisma.FeedbackOptionOmit
  feedbackQuestion?: Prisma.FeedbackQuestionOmit
  feedbackSubmission?: Prisma.FeedbackSubmissionOmit
  game?: Prisma.GameOmit
  gameDeveloper?: Prisma.GameDeveloperOmit
  gameRule?: Prisma.GameRuleOmit
  grandLaunchingRegistration?: Prisma.GrandLaunchingRegistrationOmit
  leaderBoardHistory?: Prisma.LeaderBoardHistoryOmit
  member?: Prisma.MemberOmit
  miniQuiz?: Prisma.MiniQuizOmit
  miniQuizAttempt?: Prisma.MiniQuizAttemptOmit
  miniQuizQuestion?: Prisma.MiniQuizQuestionOmit
  nominee?: Prisma.NomineeOmit
  nomineeVote?: Prisma.NomineeVoteOmit
  playgroundExpenseHistory?: Prisma.PlaygroundExpenseHistoryOmit
  playgroundRewardHistory?: Prisma.PlaygroundRewardHistoryOmit
  playgroundToken?: Prisma.PlaygroundTokenOmit
  program?: Prisma.ProgramOmit
  programRegistration?: Prisma.ProgramRegistrationOmit
  programTask?: Prisma.ProgramTaskOmit
  programTaskExtraDescription?: Prisma.ProgramTaskExtraDescriptionOmit
  programTaskSubmission?: Prisma.ProgramTaskSubmissionOmit
  project?: Prisma.ProjectOmit
  referalCodeUsage?: Prisma.ReferalCodeUsageOmit
  singleParticipant?: Prisma.SingleParticipantOmit
  team?: Prisma.TeamOmit
  userData?: Prisma.UserDataOmit
  userPlayGameHistory?: Prisma.UserPlayGameHistoryOmit
  userPlayground?: Prisma.UserPlaygroundOmit
  userPlaygroundDetention?: Prisma.UserPlaygroundDetentionOmit
  account?: Prisma.accountOmit
  rateLimit?: Prisma.rateLimitOmit
  session?: Prisma.sessionOmit
  user?: Prisma.userOmit
  verification?: Prisma.verificationOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
  GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
  : never

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw' 
  | 'groupBy'

/**
 * These options are being passed into the middleware as "params"
 */
export type MiddlewareParams = {
  model?: ModelName
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => runtime.Types.Utils.JsPromise<T>,
) => runtime.Types.Utils.JsPromise<T>

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

